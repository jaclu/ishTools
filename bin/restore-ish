#!/bin/sh
#
# Copyright (c) 2021: Jacob.Lundqvist@gmail.com 2021-04-13
# License: MIT
#
# Version: 0.3.7 2021-04-13
#                Second oops in the same day, unintentional removal of a space in
#		 patch_rc_cgroup_sh() that caused the patch to fail
#          0.3.6 2021-04-13
# 		 Ouch fixed embarrasing typo in task_sshd when sshd is disabled
#          0.3.5 2021-04-13
#                Refactored task_restore_root_home & task_restore_user
#                to use a common function for restoring home_dir and
#                extracting tarballs into a tmpdir, so that if extract fails
#                it can be removed with no ill effect on the intended home_dir
#          0.3.4 2021-04-09
#                Refactored task_sshd with propper usage of openrc
#                and possibility to select sshd port from config file.
#                In addition patching /lib/rc/sh/rc-cgroup.sh
#                to get rid of constant /proc/filesystems error messages
#                any time a service is started or stopped
#          0.3.3 2021-04-05
#                Added error check for task_install_my_software
#                if apk add fails
#          0.3.2 2021-03-29
#                Split update & upgrade and put remove in-between
#          0.3.1 2021-03-26
#                Creates user with uid/gid 501 in order to make
#                iOS mounts writable
#          0.3.0 2021-03-17
#                Major cleanup, making everything modular
#                expanding the README.md
#
# Dependency: This shell scripts  expects a config file to be present at
# ../custom/ishTols.cfg
# There is a sample config file in ../samples/ishTols.cfg copy it into the
# above location and modify it to match your preferences before running.
#
# When you run this all actions that will be done based on your config will
# be displayed, and then this app holds for 5 seconds. You can
# press Ctrl-C if you want to examine what will be done in more detail.
#
# This is a turn-key setup of a fresh iSH into a useable state
# Even if you do not have any homedirs to restore, this can be used to
# set the general environment up to your likings look at the settings bellow,
# anything that you do now wan't to bother with, 
# just comment that  out.
#
# Works both on AppStore and TestFlight iSH
# and both with default and AOK filesystems
#
# Most output lines are kept short, in order to as much as possible
# display without linebreaks on the iPhone.
#
# Copy it outside the iSH filesystem in order for it to survive a
# delete - install cycle. I use: mount -t ios . /mnt
# and then select a dir on iCloud, so I can get all my various devices
# restored from the same source. But im sure there are other ways to do it.
#
# Any feedback / bug reports welcome!
#



#==========================================================
#
#     Display functions
#
#==========================================================

error_msg() {
    msg=$1
    err_code=$2

    printf "\nERROR: $msg\n\n"

    if [ "$err_code" != "" ]; then
	prepare_extract_location 1 # clear tmp extract dir
        exit $err_code
    fi
}


#
#  Progress messages
#
msg_1() {
    #
    #   Display message centered inside a box
    #
    msg=$1
    pad_length=42
    msg_length="${#msg}"
    msg_half_length="$((${#msg}/2))"
    pad="a"
    pad_str="b"

    #
    # if msg was odd chars long, add a space to ensure it can be correctly
    # be split in half
    #
    if [ $msg_length -ne $(( msg_half_length * 2 )) ] ; then
        msg="$msg "
        msg_length="${#msg}"
    fi

    # if string is to long, dont use padding
    if [ $msg_length -ge $pad_length ]; then
        pad_str=""
    else
        pad="                                                             "
        pad_str=${pad:0:$(( (pad_length-${#msg}) / 2))}
    fi
    echo
    echo "+==========================================+"
    echo "|                                          |"
    echo "|$pad_str$msg$pad_str|"
    echo "|                                          |"
    echo "+==========================================+"
    echo
}


msg_2() {
    msg=$1

    echo "=== $msg ==="
}


msg_3() {
    msg=$1

    echo "--- $msg ---"
}



#==========================================================
#
#     Path and param handling
#
#==========================================================

prepare_extract_location() {
    remove_space=$1

    extract_location="/tmp/restore-ish-$$"
    rm $extract_location -rf
    case "$remove_space" in
	"")
	    mkdir -p $extract_location
	    cd $extract_location || error_msg "prepare_extract_location() could not cd !" 1
	    ;;
	"1")
	    ;;
	*)
	    echo
	    echo "ERROR: prepare_extract_location() accepted params: nothing|1"
	    exit 1
    esac
}

expand_path() {
    #
    #  Path not starting with / are asumed to be relative to
    #  $DEPLOY_PATH
    #
    this_path="$1"
    char_1=$(echo "$this_path" | head -c1)

    if [ "$char_1" = "/" ]; then
        expanded_path="$this_path"
    else
        expanded_path="$DEPLOY_PATH/$this_path"
    fi
}


expand_path_all_params() {
    #
    # Expands all path params that might be relative
    # to the deploy location into a full path
    #
    if [ "$repositories_file" = "*** do not touch ***" ]; then
        repositories_file=""
    elif [ "$repositories_file" != "" ] ; then
        #echo "### expanding: [$repositories_file]"
        expand_path "$repositories_file"
        repositories_file="$expanded_path"
        #echo "    expanded into: [$repositories_file]"
    else
        # Use default Alpine repofile
        repositories_file="$DEPLOY_PATH/files/repositories-Alpine-v3.12"
    fi
    if [ "$hosts_file" != "" ]; then
        #echo "### expanding: [$hosts_file]"
        expand_path "$hosts_file"
        hosts_file="$expanded_path"
        #echo "    expanded into: [$hosts_file]"
    fi
    if [ "$ssh_host_keys" != "" ]; then
        #echo "### expanding: [$ssh_host_keys]"
        expand_path "$ssh_host_keys"
        ssh_host_keys="$expanded_path"
        #echo "    expanded into: [$ssh_host_keys]"
    fi
    if [ "$my_home_dir_tgz" != "" ]; then
        #echo "### expanding: [$my_home_dir_tgz]"
        expand_path "$my_home_dir_tgz"
        my_home_dir_tgz="$expanded_path"
        #echo "    expanded into: [$my_home_dir_tgz]"
    fi
    if [ "$root_home_dir_tgz" != "" ]; then
        #echo "### expanding: [$root_home_dir_tgz]"
        expand_path "$root_home_dir_tgz"
        root_home_dir_tgz="$expanded_path"
        #echo "    expanded into: [$root_home_dir_tgz]"
    fi
    if [ "$extra_tasks" != "" ]; then
        #echo "### expanding: [$extra_tasks]"
        expand_path "$extra_tasks"
        extra_tasks="$expanded_path"
        #echo "    expanded into: [$extra_tasks]"
    fi
}


setup_environment() {
    #
    #   Identify the local env, and parse config file
    #
 
    this_host=$(hostname)  # used in config file

    #
    #  Identify fiilesystem, a lot of other operations depend on it, 
    #  should be done early
    #
    echo
    if test -d /AOK ; then
        FileSystem='AOK'
        msg_2 "This is an AOK file system"
    else
        FileSystem='iSH'
        msg_2 "This is a regular iSH file system"
    fi
    #
    # Find where this package is deployed, then use this for relative locations
    #
    DEPLOY_PATH="`dirname \"$0\"`/.."               # relative
    DEPLOY_PATH="`( cd \"$DEPLOY_PATH\" && pwd )`"  # absolutized and normalized
    test -d $DEPLOY_PATH || error_msg "could not identify DEPLOY_PATH!!" 1
    #
    # Config file
    #
    cfg_file=$DEPLOY_PATH/custom/ishTols.cfg
    if [ "$cfg_file" != "" ] && test -f $cfg_file ; then
        . "$cfg_file"
    else
        echo
        echo "ERROR: No config file ($cfg_file) found, aborting"
        echo
        echo "You should find a template config file in the samples dir of this repo,"
        echo "copy it to the above location, and tweak it to your preferences."
        echo
        exit 1
    fi
    # process path references in config file
    expand_path_all_params
    #
    # Extra checks for numerical params
    #
    if [ "$display_non_tasks" = "" ] || [ "$display_non_tasks" -ne 1 ]; then
        display_non_tasks=0
    fi
    
    [ "$activate_sshd_service" = "" ] && activate_sshd_service=0
    case "$activate_sshd_service" in
        -1|0|1)
            ;;
        *)
            error_msg "Invalid setting: activate_sshd_service=$activate_sshd_service\nValid options: -1 0 1" 1
    esac

    # Default sshd port
    if [ "$sshd_port" = "" ]; then
	sshd_port=1022
    fi

    if [ "$root_replace" = "" ] || [ "$root_replace" -ne 1 ]; then
        root_replace=0
    fi

    #
    # Unset variables depending on others
    #
    if [ "$my_uname" = "" ]; then
        my_home_dir_tgz=""
    fi
}



#==========================================================
#
#     Various
#
#==========================================================

replace_default_fs_inittab() {
    #
    # The AOK inittab is more complex, and does not need to be modified
    # to hack sshd to run at boot, so we do not touch it.
    #
    inittab

    if [ "$FileSystem" != "AOK" ]; then
	msg_3 "/etc/inittab"
	# Get rid of unused getty's
	inittab=$DEPLOY_PATH/files/inittab-default-FS
	echo "$inittab"
	if [ ! $task_display -eq 1 ]; then
	    cp "$inittab" /etc/inittab
	fi
    fi
}


#
# This hack prevents all iSH service start and stops shoving an error
# about not finding /proc/filesystems iSH does not currently suppport
# that part of /proc
# This snippet does not require bash /bin/sh is enough.
# Needs to be run as root, but since this script already has that
# requirement it should be fine.
#
patch_rc_cgroup_sh() {
    fname=/lib/rc/sh/rc-cgroup.sh
    fn_backup=${fname}.org

    # line wrapped to avoid ridiculously long line
    func_name_line_no=$(grep -n "cgroup2_find_path()" $fname |
				  cut --delimiter=":" --fields=1)
    insert_on_line=$((func_name_line_no+2))

    # In order to exand tab below, through trial and error, I discovered
    # double expanding it turned out to work. Do not ask me why...
    patch_line="\\treturn 0  # ** Hack for iSH by jaclu ***"

    msg_3 "Examining if $fname needs patching"
    
    # check content of line
    early_return=$(sed "$insert_on_line !d" $fname)

    #
    # Since bash most likely isn't available when this is first run,
    # we have to make do with /bin/sh and do string match
    #  using a case statement - argh...
    #
    case $early_return in
	*"return 0"*)
            msg_3 "Patch already applied"
	    ;;
        *)
	    msg_3 "Patch beeing applied"
	    if [ -f "$fn_backup" ]; then
		echo "Found: $fn_backup"
		echo "Seems like patch was already applied"
		echo "First try:  mv $fn_backup $fname"
		echo "And then run this again, after that double check $fname"
		echo "To make sure cgroup2_find_path() returns 0"
		error_msg "Found $fn_backup read the above for further suggestions" 1		
	    fi
	    echo "Making cgroup2_find_path() always return 0"
	    echo "Saving original file to $fn_backup"
	    cp $fname $fn_backup

	    # kind of RPN, end result is an empty line after the patch line.
	    # and the patch ends up on the expected line so will be detected
	    # on later runs of this
	    sed -i "$insert_on_line i \ " $fname
	    sed -i "$insert_on_line i \ $patch_line" $fname
	    
	    msg_3 "Patch completed!"
            ;;
    esac
}


ensure_user_shell_is_installed() {
    if [ $task_display -eq 1 ]; then
        test -x $user_shell || error_msg "$user_shell not found\n>>> Make sure it gets installed!<<<\n"
    else
        test -x $user_shell || error_msg "INVALID SHELL: $user_shell" 1
    fi   
}


#
#  Restore $home_dir unless $unpacked_ptr points to an existing file.
#  If $save_current is 1, curent home dir is moved to $home_dir-OLD and
#  always restored.
#
unpack_home_dir() {
    username=$1
    home_dir=$2
    fname_tgz=$3
    unpacked_ptr=$4
    save_current=$5

    # Initialized params
    #echo "unpack_home_dir($username,$home_dir,$fname_tgz,$unpacked_ptr,$save_current)"

    #
    #  Param checks
    #
    # Some of the checks below are ignored when $task_display is 1 ie just inforoming what will happen
    if [ "$username" = "" ]; then
	error_msg "unpack_home_dir() no username given" 1
    fi
    if [ ! $task_display -eq 1 ] && [ "$(grep ^$username /etc/passwd | wc -l)" != "1" ]; then
	error_msg "unpack_home_dir($username) - username not found in /etc/passwd" 1
    fi
    if [ "$home_dir" = "" ]; then
        error_msg "unpack_home_dir() no home_dir given" 1
    fi
    if [ ! $task_display -eq 1 ] && [ ! -d "$home_dir" ]; then
        error_msg "unpack_home_dir($username, $home_dir) - home_dir does not exist" 1
    fi
    if [ ! $task_display -eq 1 ] && [ "$(ls -ld $home_dir | awk '{print $3}')" != "$username" ]; then
        error_msg "unpack_home_dir($username, $home_dir) - username does not own home_dir" 1
    fi
    if [ "$fname_tgz" = "" ] || [ "$fname_tgz" = "1" ]; then
	error_msg "unpack_home_dir($username, $home_dir,) - No tar file to be extracted given" 1
    fi
    if ! test -f $fname_tgz ; then
    	error_msg "tar file not found:\n[$fname_tgz]" 1
    fi 
    case "$unpacked_ptr" in
	"0"|"1" )
  	    # Not actual error, no unpacked_ptr given so save_current got shifted here"
	    save_current=$unpacked_ptr
	    unpacked_ptr=""
 	    ;;
	*)
	   
    esac
    [ "$save_current" != "1" ] && save_current=0
    # Parsed, and in some cases reshuffeled params
    #echo "unpack_home_dir($username,$home_dir,$fname_tgz,$unpacked_ptr,$save_current)"
 
    #
    #  Actual work starts
    #
    msg_2 "$msg_txt"
    if [ $save_current -eq 1 ]; then
	do_unpack=1 # always restore
    else
    	if test -f $unpacked_ptr && [ "$unpacked_ptr" != "" ] ; then
            msg_3 "Already restored"
            echo "Found: $unpacked_ptr"
            do_unpack=0
	else
            do_unpack=1
   	fi
    fi
    if [ $do_unpack -eq 1 ]; then
        if [ $task_display -eq 1 ]; then
	    msg_3 "Will be restored"
 	    echo "Using: $fname_tgz"
	    if [ $save_current -eq 1 ]; then
		msg_3 "Previous content will be moved to ${home_dir}-OLD"
	    fi
	else
	    prepare_extract_location
	    msg_3 "Extracting"
	    echo $fname_tgz
	    2> /dev/null tar xfz "$fname_tgz"
	    if [ $? -ne 0 ]; then
		error_msg "Failed to unpack tarball" 1
	    fi
	    if [ ! -d "$extract_location/$username" ]; then
		error_msg "No $username top dir found in the tarfile!" 1
	    elif [ "$(find . -maxdepth 1 | wc -l)" != "2" ]; then
		# suspicious
		error_msg "Content outside intended destination found, check the tarfile!" 1
	    fi
 	    echo "Done"
	    if [ $save_current -eq 1 ]; then
		rm ${home_dir}-OLD -rf
		mv $home_dir ${home_dir}-OLD
		msg_3 "Previous content has been moved to ${home_dir}-OLD"
		mv $username $home_dir
	    else
		msg_3 "Overwriting into current $home_dir"
		cd $home_dir || error_msg "Failed to cd into $home_dir" 1
		cd ..
		cp -a "$extract_location/$username" .
	    fi
            msg_3 "$home_dir restored"
	    prepare_extract_location 1  # Remove tmp directory
        fi
    fi
}



#==========================================================
#
#   Tasks, displays intended action or performs it,
#   based on $task_display
#     1     Display what will be done 
#     0     Do action
#
#   All tasks are called twice via run_tasks()
#   The first time task_display is 1, this is to show
#   information about what actions will be taken, after
#   wich there is a pause to allow the user to hit Ctrl-C
#   If the summary needs to be examined more indepth.
#   If there is no break, after the pause (currently 5s),
#   task_display is set to 0, and all active tasks are once
#   again called, this time with the asumption that the announced
#   task will now be performed.
#
#==========================================================

task_aok_tweaks() {
    prof_dbg=/tmp/profile.debug

    if [ "$FileSystem" = "AOK" ]; then
        msg_2 "Some AOK tweaks"
        # If this file isnt globaly writeable, you will get errors if you login
        # as somebody else than the first one who logged in...
        if [ "$prof_dbg" != "" ] && test -f $prof_dbg ; then
            msg_3 "chmod 666 $prof_dbg"
            chmod 666 "$prof_dbg"
        fi
    echo
    fi
}


task_replace_some_etc_files() {
    msg_2 "Copying some files to /etc"
    # If the config file is not found, no action will be taken

    # Add my local hosts
    msg_txt="/etc/hosts"
    if [ "$hosts_file" != "" ]; then
        msg_3 "$msg_txt"
        test -f $hosts_file || error_msg "hosts_file not found!\n$hosts_file" 1
        echo "$hosts_file"
        if [ ! $task_display -eq 1 ]; then
            cp "$hosts_file"  /etc/hosts
        fi
    elif [ $task_display -eq 1 ] &&  [ $display_non_tasks -eq 1 ]; then
        msg_3 "$msg_txt"
        echo "Will NOT be modified"
    fi

    msg_txt="/etc/apk/repositories"
    if  [ "$repositories_file" != "" ]; then
        msg_3 "$msg_txt"
        test -f $repositories_file || error_msg "repositories_file not found!\n$repositories_file" 1
        echo "$repositories_file"
        if [ ! $task_display -eq 1 ]; then
            cp "$repositories_file" /etc/apk/repositories
        fi
    elif [ $task_display -eq 1 ] &&  [ $display_non_tasks -eq 1 ]; then
        msg_3 "$msg_txt"
        echo "Will NOT be modified"
    fi
    replace_default_fs_inittab
    echo
}


task_update() {
    msg_2 "update & fix apk index"
    if [ $task_display -eq 1 ]; then
        msg_3 "Will happen"
    else
        apk update && apk fix
        [ $? -ne 0 ] && error_msg "Failed to update repos - network issue?" 1
    fi
    echo
}


task_remove_software() {
    msg_txt="Removing unwanted software"

    if [ "$sw_removed" != "" ]; then
        msg_2 "$msg_txt"
        if [ $task_display -eq 1 ]; then
            echo "$sw_removed"
        else
            apk del $sw_removed
        fi
        echo
    elif [ $task_display -eq 1 ] &&  [ $display_non_tasks -eq 1 ]; then
        msg_2 "$msg_txt"
        echo "Will NOT remove any listed software"
        echo
    fi
}


task_upgrade() {
    msg_2 "upgrade installed apks"
    if [ $task_display -eq 1 ]; then
        msg_3 "Will happen"
    else
        apk upgrade
        [ $? -ne 0 ] && error_msg "Failed to upgrade apks - network issue?" 1
    fi
    echo
}


task_install_my_software() {
    msg_txt="Installing my selection of software"
    if [ "$sw_installed" != "" ]; then
        msg_2 "$msg_txt"
        if [ $task_display -eq 1 ]; then
            echo "$sw_installed"
        else
            apk add $sw_installed
            [ $? -ne 0 ] && error_msg "Failed to install requested software - network issue?" 1
	fi
        echo
    elif [ $task_display -eq 1 ] &&  [ $display_non_tasks -eq 1 ]; then
        msg_2 "$msg_txt"
        echo "Will NOT install any listed software"
        echo
    fi
}


task_timezone() {
    msg_txt="Setting timezone"
    tz_file=/usr/share/zoneinfo/$time_zone

    if [ "$time_zone" != "" ]; then
        msg_2 "$msg_txt"
        echo "$time_zone"
        if [ ! $task_display -eq 1 ]; then
            test -f /usr/sbin/zic || apk add tzdata
            if [ "$tz_file" != "" ] && test -f $tz_file ; then
                cp "$tz_file" /etc/localtime
                # remove obsolete file
                2> /dev/null rm /etc/timezone
                msg_3 "displaying time"
                date
            else
                error_msg "BAD TIMEZONE: $time_zone" 1
            fi
        fi
        echo
    elif [ $task_display -eq 1 ] &&  [ $display_non_tasks -eq 1 ]; then
        msg_2 "$msg_txt"
        echo "Timezone ill NOT be changed"
        echo
    fi
}


task_ssh_host_keys() {
    #
    #  Even if you don't intend to activate sshd initially
    #  it still makes sende to deploy any saved ssh host keys
    #  A) they are there if you need them
    #  B) you dont have to wait for host keys to be generated
    #     when and if you want to run sshd
    #
    msg_txt="Device specific ssh host keys"

    if [ "$ssh_host_keys" != "" ]; then
        msg_2 "$msg_txt"
        if test -f $ssh_host_keys ; then
            msg_3 "Will be untared into /etc/ssh"
            echo "$ssh_host_keys"
            if [ ! $task_display -eq 1 ]; then
                test -d /etc/ssh || apk add openssh-client
                cd /etc/ssh
                2>/dev/null rm /etc/ssh/ssh_host_*
                tar xvfz "$ssh_host_keys"
            fi
        else
            msg_3 "Not found"
            echo "$ssh_host_keys"
        fi
    elif [ $task_display -eq 1 ] &&  [ $display_non_tasks -eq 1 ]; then
        msg_2 "$msg_txt"
        echo "Will NOT be used"
    fi
    echo
}


task_sshd() {
    msg_txt="sshd service"
    case "$activate_sshd_service" in
        -1 ) # disable
            msg_2 "$msg_txt"
            msg_3 "will be disabled"
            if [ ! $task_display -eq 1 ]; then			
                if [ "$(2> /dev/null rc-status |grep sshd)" != "" ]; then
    		    openrc default
		    rc-service sshd stop
        	    rc-update del sshd
		    msg_3 "was disabled"
                else
                    echo "sshd not active, no action needed"
                fi
            fi
            ;;
        0 )  # unchanged
            if [ $task_display -eq 1 ] &&  [ $display_non_tasks -eq 1 ]; then
                msg_2 "$msg_txt"
                echo "Will NOT be changed"
            fi

            ;;
	
        1 )  # activate 
            msg_2 "$msg_txt"
	    if [ "$sshd_port" = "" ]; then
		error_msg "Invalid setting: sshd_port must be specified" 1
	    fi
            msg_3 "Will be enabled"
	    # This will be run regardless if it was already running,
	    # since the sshd_config might have changed
            if [ ! $task_display -eq 1 ]; then
		msg_3 "Installing openssh & openrc"
		apk add openssh openrc
		# use requested port
		sed -i "s/.*Port.*/Port $sshd_port/" /etc/ssh/sshd_config
		patch_rc_cgroup_sh
		# activate service
		openrc default
		rc-update add sshd
		# in case some config changes happened, make sure its restarted
		rc-service sshd restart
		msg_1 "sshd listening on port: $sshd_port"
            fi
            ;;
        *)
            error_msg "Invalid setting: activate_sshd_service=$activate_sshd_service\nValid options: -1 0 1" 1
    esac
    echo
}


task_nopasswd_sudo() {
    msg_2 "no-pw sudo for group wheel"
    echo "will be set if not done already"
    if [ ! $task_display -eq 1 ]; then
        test -f /usr/sbin/visudo || apk add sudo
        grep restore-ish /etc/sudoers > /dev/null
        if [ $? -eq 1 ]; then
            msg_3 "adding %wheel NOPASSWD to /etc/sudoers"
            echo "%wheel ALL=(ALL) NOPASSWD: ALL # added by restore-ish" >> /etc/sudoers
        else
            msg_3 "pressent"
        fi
    fi
    echo
}


task_restore_root_home() {
    msg_txt="Restoration of /root"
    tar_test_result
    
    if [ "$root_home_dir_tgz" != "" ]; then
	unpack_home_dir root /root $root_home_dir_tgz $root_home_dir_unpacked_ptr $root_replace
    fi
    echo
}


task_restore_user() {
    msg_txt="Username: $my_uname"
    user_shell=${my_shell:-/bin/ash}

    if [ "$my_uname" != "" ]; then
	#
	# Ensure user is created
	#
        msg_2 "$msg_txt"
        grep ^$my_uname /etc/passwd > /dev/null
        if [ $? -eq 1 ]; then
            msg_3 "Will be created"
            msg_3 "shell: $user_shell"
            ensure_user_shell_is_installed
            # ensure shadow and hence adduser is installed
            if [ ! $task_display -eq 1 ]; then
                if ! test -n $(which useradd) ; then
                    msg_3 "Adding shadow (provides useradd)"
                    apk add shadow
                fi
		# we need to ensure the group exists, before using it in useradd
		# TODO: identidy a 501 group by name and delete it
		groupdel -g $my_uname 2> /dev/null
		groupadd -g 501 $my_uname 
		# sets uid & gid to 501, to match apples uid/gid on iOS mounts
                useradd -u 501 -g 501 -G wheel -m -s $user_shell $my_uname
            fi
        else
            msg_3 "Already pressent"
            ensure_user_shell_is_installed
        fi
        echo
	
   	#
	# Restore user home
	#
	if [ "$my_home_dir_tgz" != "" ]; then
            msg_txt="Restoration of /home/$my_uname"
	    unpack_home_dir $my_uname /home/$my_uname "$my_home_dir_tgz" "$my_home_dir_unpacked_ptr"
	fi
    elif [ $task_display -eq 1 ] &&  [ $display_non_tasks -eq 1 ]; then
        msg_2 "Will NOT create any user"
    fi
    echo
}


task_do_extra_tasks() {
    msg_txt="Running additional local restore tasks"

    if [ "$extra_tasks" != "" ]; then
        if [ $task_display -eq 1 ]; then
            msg_2 "$msg_txt"
        else
            msg_1 "$msg_txt"
        fi
        echo "Script: $extra_tasks"
        test -f $extra_tasks || error_msg "script not found" 1
        test -x $extra_tasks || error_msg "script not executable" 1
        echo
        [ $task_display -eq 1 ] || . "$extra_tasks"
    elif [ $task_display -eq 1 ] &&  [ $display_non_tasks -eq 1 ]; then
        msg_2 "NO extra tasks will be run"
    fi
    echo
}


task_user_pw_reminder() {
    [ $task_display -eq 1 ] && return

    if [ "$my_uname" != "" ] && [ "$(grep $my_uname:\!: /etc/shadow)" != "" ]; then
        echo "+------------------------------+"
        echo "|                              |"
        echo "|  Remember to set a password  |"
        echo "|  for your added user:        |"
        echo "|    sudo passwd $my_uname"
        echo "|                              |"
        echo "+------------------------------+"
        echo
    fi
}



#==========================================================
#
#     Main
#
#==========================================================

#
# If task_display=1 then what will be done is displayed
# otherwise the tasks are performed
#
run_tasks() {
    #
    # For testing/debugging any of the tasks can be commented out
    # It is probably not a good idea to reshuffle their order too much
    # some of them depend on previous tasks
    #
    task_aok_tweaks
    task_replace_some_etc_files

    task_update
    # do before upgrade to avoid time waste of upgrading
    # only to then remove it
    task_remove_software
    task_upgrade

    task_install_my_software
    task_timezone
    task_ssh_host_keys
    task_sshd
    task_nopasswd_sudo
    task_restore_root_home
    task_restore_user
    task_do_extra_tasks
    task_user_pw_reminder
}


#
#  Debug tasks, set condition as 
#    0 = 1 for normal operation
#    1 = 1 to run the test
#
if [ 0 = 1 ]; then
    # Testing specific task(-s)
    # only those listed below will be run
    run_tasks() {
	task_sshd
    }
    # no need to wait if you are testing tasks...
    wait_after_summary=0
else
    # Normal operation
    wait_after_summary=5
fi


setup_environment

#
# Display all tasks
#
task_display=1
echo
msg_1 "Displaying what tasks will be performed"
run_tasks
echo
echo "Press Ctrl-C if you want to have more time"
echo "to observe the changes that will be done."
echo
echo "Waiting $wait_after_summary secs, in case you want to abort..."
echo
sleep $wait_after_summary

#
# Do all tasks
#
task_display=0
msg_1 "Restore begins"
run_tasks


# Ensure tmp directory is gone
prepare_extract_location 1

msg_2 "All done, system restored!"
