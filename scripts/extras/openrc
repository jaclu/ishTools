#==========================================================
#
#     runlevels and services
#
#==========================================================

#
# Makes sure openrc is installed, and that default is the current runlevel.
# ATM some fixes are done before checking current runlevel:
#  1 deploy a patch to workaround the lacking /proc implementation in iSH
#  2 remove a service that complains about a broken dependency.
#    Since it isn't meaningful to run on an iOS device anyhow,
#    the simple solution is to just remove the file for now.
#
ensure_runlevel_default() {
    ensure_installed openrc
    patch_rc_cgroup_sh

    bad_srvc=/etc/init.d/hwdrivers
    if test -f "$bad_srvc" ; then
	#
	# TODO: check if this is no longer needed in order to avoid getting
	# warnings about hwdrivers not finding dependency 'dev'
	# Still needed: 2021-04-27
	#
	echo
	echo "============================================================"
	echo "Removing a failing service: $bad_srvc"
	echo "To avoid pointless warnings about non existent dependency."
	echo "Reinstalling openrc package should recreate this file"
	echo "============================================================"
	echo
	rm "$bad_srvc"
    fi
    
    if [ "$(rc-status -r)" != "default" ]; then
	msg_2 "Setting runlevel default"
	openrc default
    fi
}


#
# Adds service mentioned in param1 to default runlevel
# if param2 is restart will restart the service once it it added
#
ensure_service_is_added() {
    srvc=$1
    restart=$2 
    [ "$srvc" = "" ] && error_msg "ensure_service_is_added() called without param" 1
    if [ "$(rc-status  | grep $srvc | grep started)" = "" ]; then
	# activate service
	rc-update add $srvc
    fi
    [ "$restart" = "restart" ] && rc-service $srvc restart
}


#
# This hack prevents all iSH service start and stops shoving an error
# about not finding /proc/filesystems iSH does not currently suppport
# that part of /proc
# This snippet does not require bash /bin/sh is enough.
# Needs to be run as root, but since this script already has that
# requirement it should be fine.
#
patch_rc_cgroup_sh() {
    fname=/lib/rc/sh/rc-cgroup.sh
    fn_backup=${fname}.org

    ensure_installed coreutils
    
    # line wrapped to avoid ridiculously long line
    func_name_line_no=$(grep -n "cgroup2_find_path()" $fname | cut --delimiter=":" --fields=1)
    insert_on_line=$((func_name_line_no+2))

    # In order to exand tab below, through trial and error, I discovered
    # double expanding it turned out to work. Do not ask me why...
    patch_line="\\treturn 0  # ** Hack for iSH by jaclu ***"

    msg_3 "Examining if $fname needs patching"
    
    # check content of line
    early_return=$(sed "$insert_on_line !d" $fname)

    #
    # Since bash most likely isn't available when this is first run,
    # we have to make do with /bin/sh and do string match
    #  using a case statement - argh...
    #
    case $early_return in
	*"return 0"*)
            msg_3 "Patch already applied"
	    ;;
        *)
	    msg_3 "Patch beeing applied"
	    if [ -f "$fn_backup" ]; then
		echo "Found: $fn_backup"
		echo "Seems like patch was already applied"
		echo "First try:  mv $fn_backup $fname"
		echo "And then run this again, after that double check $fname"
		echo "To make sure cgroup2_find_path() returns 0"
		error_msg "Found $fn_backup read the above for further suggestions" 1		
	    fi
	    echo "Making cgroup2_find_path() always return 0"
	    echo "Saving original file to $fn_backup"
	    cp $fname $fn_backup

	    # kind of RPN, end result is an empty line after the patch line.
	    # and the patch ends up on the expected line so will be detected
	    # on later runs of this
	    sed -i "$insert_on_line i \ " $fname
	    sed -i "$insert_on_line i \ $patch_line" $fname
	    
	    msg_3 "Patch completed!"
            ;;
    esac
}


